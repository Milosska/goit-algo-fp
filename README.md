# Фінальний проєкт з курсу "Basic Algorithms and Data Structures" 
Фінальний проєкт курсу, що охоплює всі пройдені теми і складається з 7 завдань. 

## Інструкція щодо використання репозиторію

1. Склонуйте репозиторій

```bash
git clone [repository-url]
cd goit-algo-fp
```

2. Перейдіть у директорію проєкту та активуйте віртуальне середовище

```bash
 python -m venv .venv
 # On Windows:
 .venv\Scripts\activate
 # On Unix/MacOS:
 source .venv/bin/activate
```

3. Встановіть необхідні залежності

```bash
# Install all dependencies (including development tools)
pip install -r requirements.txt
```

4. Запустіть головний файл main.py у відповідній папці проєкту

```bash
python -m task_1.main
```

## Завдання 1: Структури даних. Сортування. Робота з однозв'язним списком
У цьому завданні реалізовано основні операції над однозв’язним списком:  

- Реверсування списку (reverse_list)  
- Сортування списку алгоритмом злиттям (merge_sort)  
- Злиття двох відсортованих списків у новий відсортований список (merge_sorted_lists)

### Основні моменти реалізації

**Структура даних:**
- Реалізацію класів `Node` та `LinkedList` взято з навчального конспекту

**Реверсування списку (`reverse_list`):**
- Змінює напрямок усіх посилань між вузлами ітеративно
- Виконується без створення нових вузлів, на місці
- Складність: O(n) за часом, O(1) за пам'яттю

**Сортування злиттям (`sort`):**
- Використовує алгоритм merge sort, адаптований для однозв'язних списків
- Застосовує техніку "повільного та швидкого покажчиків" для знаходження середини
- Рекурсивно ділить список і зливає відсортовані частини
- Складність: O(n log n) за часом, O(log n) за пам'яттю (стек рекурсії)

**Злиття відсортованих списків (`get_merge_sorted_lists`):**
- Приймає два відсортовані LinkedList об'єкти
- Створює новий LinkedList з об'єднаними та відсортованими елементами
- Використовує допоміжну функцію `merge_sorted_lists` з модуля алгоритмів
- Складність: O(n + m), де n і m - розміри списків

**Технічні деталі:**
- Всі операції виконуються на рівні вузлів для оптимальної ефективності
- Включає допоміжні функції (`create_linked_list_from_array`) для зручності роботи
- Демонстраційна програма показує всі реалізовані можливості
- Інтегровано з системою обробки помилок через декоратори

## Завдання 2: Рекурсія. Створення фрактала "дерево Піфагора"
У цьому завданні реалізовано програму для створення фрактала "дерево Піфагора" з використанням рекурсії та візуалізації за допомогою бібліотеки turtle.

### Основні моменти реалізації

**Структура даних:**
- Використовується модуль turtle для графічної візуалізації
- Система обробки помилок через власні винятки та декоратори

**Парсинг рівня рекурсії (`parse_rec_depth`):**
- Валідує введений користувачем рівень рекурсії
- Викидає `DepthValueIsNotValidException` у разі некоректного вводу

**Рекурсивне малювання гілки (`draw_pythagoras_branch`):**
- Рекурсивно малює одну гілку дерева Піфагора
- Складність: O(2^n) за часом, O(n) за пам'яттю (стек рекурсії)

**Головна функція малювання (`draw_pythagoras_tree`):**
- Налаштовує початкові параметри черепашки (швидкість, позицію)
- Встановлює початкову орієнтацію (90° вгору)
- Викликає рекурсивну функцію з початковою довжиною 200 пікселів

**Технічні деталі:**
- Використовує бібліотеку turtle для 2D графіки
- Кожна гілка розгалужується на дві підгілки під кутами ±45°
- Коефіцієнт зменшення довжини гілок: 0.7
- Інтегровано з системою обробки помилок через декоратори

## Завдання 3: Дерева, алгоритм Дейкстри
У цьому завданні реалізовано алгоритм Дейкстри для знаходження найкоротших шляхів у зваженому графі з використанням бінарної купи. Завдання включає створення графа, використання піраміди для оптимізації вибору вершин та обчислення найкоротших шляхів від початкової вершини до всіх інших.

### Основні моменти реалізації

**Структура даних:**
- Використовується бібліотека NetworkX для роботи з графами
- Візуалізація графу за допомогою matplotlib
- Граф представляє населені пункти Обухівської громади Київської області

**Створення графу (`initialize_graph`):**
- Створює неорієнтований граф з 21 населеним пунктом
- Вершини мають атрибути: вага (розмір для візуалізації) і колір
- Ребра представляють відстані між населеними пунктами в кілометрах
- Координати вершин відповідають реальним географічним координатам

**Візуалізація графу (`handle_graph_build`):**
- Використовує реальні географічні координати для позиціонування вершин
- Розмір вузлів залежить від їх ваги (обернено пропорційно)
- Кольорове кодування: червоний (центр), синій (великі міста), зелений (села)

**Алгоритм Дейкстри (`dijkstra_heap_algorithm`):**
- Реалізований з використанням бінарної купи (heapq)
- Повертає найкоротші відстані та повні маршрути до всіх вершин
- Складність: O((V + E) log V), де V - кількість вершин, E - кількість ребер
- Оптимізований для роботи з великими графами

**Обробка результатів (`handle_dijkstra`):**
- Запускає алгоритм Дейкстри від заданої початкової вершини (за замовчуванням "Обухів")
- Виводить найкоротші маршрути у читаному форматі
- Показує послідовність населених пунктів та загальну протяжність маршруту

**Технічні деталі:**
- Граф містить 21 вершину та 23 ребра
- Бінарна купа забезпечує ефективний вибір наступної вершини з мінімальною відстанню
- Зберігається повна інформація про маршрут (не лише відстань)
- Інтегровано з системою обробки помилок через декоратори
- Підтримка відображення українських назв населених пунктів
