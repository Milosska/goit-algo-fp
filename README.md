# Фінальний проєкт з курсу "Basic Algorithms and Data Structures" 
Фінальний проєкт курсу, що охоплює всі пройдені теми і складається з 7 завдань. 

## Інструкція щодо використання репозиторію

1. Склонуйте репозиторій

```bash
git clone [repository-url]
cd goit-algo-fp
```

2. Перейдіть у директорію проєкту та активуйте віртуальне середовище

```bash
 python -m venv .venv
 # On Windows:
 .venv\Scripts\activate
 # On Unix/MacOS:
 source .venv/bin/activate
```

3. Встановіть необхідні залежності

```bash
# Install all dependencies (including development tools)
pip install -r requirements.txt
```

4. Запустіть головний файл main.py у відповідній папці проєкту

```bash
python -m task_1.main
```

## Завдання 1: Структури даних. Сортування. Робота з однозв'язним списком
У цьому завданні реалізовано основні операції над однозв’язним списком:  

- Реверсування списку (reverse_list)  
- Сортування списку алгоритмом злиттям (merge_sort)  
- Злиття двох відсортованих списків у новий відсортований список (merge_sorted_lists)

### Основні моменти реалізації

**Структура даних:**
- Реалізацію класів `Node` та `LinkedList` взято з навчального конспекту

**Реверсування списку (`reverse_list`):**
- Змінює напрямок усіх посилань між вузлами ітеративно
- Виконується без створення нових вузлів, на місці
- Складність: O(n) за часом, O(1) за пам'яттю

**Сортування злиттям (`sort`):**
- Використовує алгоритм merge sort, адаптований для однозв'язних списків
- Застосовує техніку "повільного та швидкого покажчиків" для знаходження середини
- Рекурсивно ділить список і зливає відсортовані частини
- Складність: O(n log n) за часом, O(log n) за пам'яттю (стек рекурсії)

**Злиття відсортованих списків (`get_merge_sorted_lists`):**
- Приймає два відсортовані LinkedList об'єкти
- Створює новий LinkedList з об'єднаними та відсортованими елементами
- Використовує допоміжну функцію `merge_sorted_lists` з модуля алгоритмів
- Складність: O(n + m), де n і m - розміри списків

**Технічні деталі:**
- Всі операції виконуються на рівні вузлів для оптимальної ефективності
- Включає допоміжні функції (`create_linked_list_from_array`) для зручності роботи
- Демонстраційна програма показує всі реалізовані можливості
- Інтегровано з системою обробки помилок через декоратори

## Завдання 2: Рекурсія. Створення фрактала "дерево Піфагора"
У цьому завданні реалізовано програму для створення фрактала "дерево Піфагора" з використанням рекурсії та візуалізації за допомогою бібліотеки turtle.

### Основні моменти реалізації

**Структура даних:**
- Використовується модуль turtle для графічної візуалізації
- Система обробки помилок через власні винятки та декоратори

**Парсинг рівня рекурсії (`parse_rec_depth`):**
- Валідує введений користувачем рівень рекурсії
- Викидає `DepthValueIsNotValidException` у разі некоректного вводу

**Рекурсивне малювання гілки (`draw_pythagoras_branch`):**
- Рекурсивно малює одну гілку дерева Піфагора
- Складність: O(2^n) за часом, O(n) за пам'яттю (стек рекурсії)

**Головна функція малювання (`draw_pythagoras_tree`):**
- Налаштовує початкові параметри черепашки (швидкість, позицію)
- Встановлює початкову орієнтацію (90° вгору)
- Викликає рекурсивну функцію з початковою довжиною 200 пікселів

**Технічні деталі:**
- Використовує бібліотеку turtle для 2D графіки
- Кожна гілка розгалужується на дві підгілки під кутами ±45°
- Коефіцієнт зменшення довжини гілок: 0.7
- Інтегровано з системою обробки помилок через декоратори
